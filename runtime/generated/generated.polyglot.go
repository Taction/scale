// Code generated by polyglot-go 0.5.0, DO NOT EDIT.
// source: runtime/generated/generated.proto

package generated

import (
	"errors"
	"github.com/loopholelabs/polyglot-go"
)

var (
	NilDecode = errors.New("cannot decode into a nil root struct")
)

type Context struct {
	Request  *Request
	Response *Response
}

func NewContext() *Context {
	return &Context{
		Request:  NewRequest(),
		Response: NewResponse(),
	}
}

func (x *Context) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Context) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {

		x.Request.Encode(b)
		x.Response.Encode(b)
	}
}

func (x *Context) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Context) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error

	if x.Request == nil {
		x.Request = NewRequest()
	}
	err = x.Request.decode(d)
	if err != nil {
		return err
	}
	if x.Response == nil {
		x.Response = NewResponse()
	}
	err = x.Response.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type RequestHeadersMap map[string]*StringList

func NewRequestHeadersMap(size uint32) map[string]*StringList {
	return make(map[string]*StringList, size)
}

func (x RequestHeadersMap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		polyglot.Encoder(b).Map(uint32(len(x)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x {
			polyglot.Encoder(b).String(k)
			v.Encode(b)
		}
	}
}

func (x RequestHeadersMap) decode(d *polyglot.Decoder, size uint32) error {
	if size == 0 {
		return nil
	}
	var k string
	var v *StringList
	var err error
	for i := uint32(0); i < size; i++ {
		k, err = d.String()
		if err != nil {
			return err
		}
		v = NewStringList()
		err = v.decode(d)
		if err != nil {
			return err
		}
		x[k] = v
	}
	return nil
}

type Request struct {
	Headers       RequestHeadersMap
	Method        string
	ContentLength int64
	Protocol      string
	IP            string
	Body          []byte
}

func NewRequest() *Request {
	return &Request{}
}

func (x *Request) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Request) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {

		polyglot.Encoder(b).String(x.Method).Int64(x.ContentLength).String(x.Protocol).String(x.IP).Bytes(x.Body)
		x.Headers.Encode(b)
	}
}

func (x *Request) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Request) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error

	x.Method, err = d.String()
	if err != nil {
		return err
	}
	x.ContentLength, err = d.Int64()
	if err != nil {
		return err
	}
	x.Protocol, err = d.String()
	if err != nil {
		return err
	}
	x.IP, err = d.String()
	if err != nil {
		return err
	}
	x.Body, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	if !d.Nil() {
		HeadersSize, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
		if err != nil {
			return err
		}
		x.Headers = NewRequestHeadersMap(HeadersSize)
		err = x.Headers.decode(d, HeadersSize)
		if err != nil {
			return err
		}
	}
	return nil
}

type ResponseHeadersMap map[string]*StringList

func NewResponseHeadersMap(size uint32) map[string]*StringList {
	return make(map[string]*StringList, size)
}

func (x ResponseHeadersMap) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		polyglot.Encoder(b).Map(uint32(len(x)), polyglot.StringKind, polyglot.AnyKind)
		for k, v := range x {
			polyglot.Encoder(b).String(k)
			v.Encode(b)
		}
	}
}

func (x ResponseHeadersMap) decode(d *polyglot.Decoder, size uint32) error {
	if size == 0 {
		return nil
	}
	var k string
	var v *StringList
	var err error
	for i := uint32(0); i < size; i++ {
		k, err = d.String()
		if err != nil {
			return err
		}
		v = NewStringList()
		err = v.decode(d)
		if err != nil {
			return err
		}
		x[k] = v
	}
	return nil
}

type Response struct {
	Headers    ResponseHeadersMap
	StatusCode int32
	Body       []byte
}

func NewResponse() *Response {
	return &Response{}
}

func (x *Response) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *Response) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {

		polyglot.Encoder(b).Int32(x.StatusCode).Bytes(x.Body)
		x.Headers.Encode(b)
	}
}

func (x *Response) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *Response) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error

	x.StatusCode, err = d.Int32()
	if err != nil {
		return err
	}
	x.Body, err = d.Bytes(nil)
	if err != nil {
		return err
	}
	if !d.Nil() {
		HeadersSize, err := d.Map(polyglot.StringKind, polyglot.AnyKind)
		if err != nil {
			return err
		}
		x.Headers = NewResponseHeadersMap(HeadersSize)
		err = x.Headers.decode(d, HeadersSize)
		if err != nil {
			return err
		}
	}
	return nil
}

type StringList struct {
	Value []string
}

func NewStringList() *StringList {
	return &StringList{}
}

func (x *StringList) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *StringList) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {

		polyglot.Encoder(b).Slice(uint32(len(x.Value)), polyglot.StringKind)
		for _, v := range x.Value {
			polyglot.Encoder(b).String(v)
		}
	}
}

func (x *StringList) Decode(b []byte) error {
	if x == nil {
		return NilDecode
	}
	d := polyglot.GetDecoder(b)
	defer d.Return()
	return x.decode(d)
}

func (x *StringList) decode(d *polyglot.Decoder) error {
	if d.Nil() {
		return nil
	}

	var err error

	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Value)) != sliceSize {
		x.Value = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Value[i], err = d.String()
		if err != nil {
			return err
		}
	}
	return nil
}
